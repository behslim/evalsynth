% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evalsynth.R
\name{Compute_Measure}
\alias{Compute_Measure}
\title{Compute a Utility and Risk Measure}
\usage{
Compute_Measure(
  x,
  x_link,
  measure,
  col_info = NULL,
  resamp.method = "perm",
  sensitive_var = NULL,
  sensitive_conti_k = FALSE,
  conti_var = FALSE,
  K_list = FALSE,
  scale = NULL,
  thres = NULL,
  iteration = 1,
  n_sampling = FALSE,
  cl_target = NULL,
  cl_measure = "True",
  cl_m = 1
)
}
\arguments{
\item{x}{data.frame; original data}

\item{x_link}{data.frame; synthetic data}

\item{measure}{character; utility and risk measures \{ "w_distance", "kl_divergence", "pmse", "standard_pmse", "alpha_precision", "beta_recall", "cl_overlap", "idr", "cap", "pop_uni", "record_linkage", "mia", "dcr", "nndr", "authen" \}}

\item{col_info}{list of column position information; \{ "cont": continuous, "cate": category, "ordi": ordinary (dcr, nndr only)\}; using measure: "w_distance", "kl_divergence", "js_divergence", "dcr", "nndr"}

\item{resamp.method}{character vector of resampling method, input NULL when not using this function; \{ "perm", "pairs", "none" \}}

\item{sensitive_var}{character vector of sensitive variables names(= block column); using measure: "idr", "cap", "record_linkage"}

\item{sensitive_conti_k}{column position information list of sensitive variables; using measure: "idr"}

\item{conti_var}{character vector of continuous variables; There is information that overlaps with col_info, but there is a function that receives parameters in that format. using measure: "cap", "pop_uni"}

\item{K_list}{integer vector of center k values to be used for clustering; using measure: "cap", "pop_uni"}

\item{scale}{numeric vector of record linkage scale by column; using measure: "record_linkage"}

\item{thres}{integer of record linkage threshold; using measure: "record_linkage"}

\item{iteration}{integer of record linkage iteration; Number of iterations to use in random sampling of record linkage; default=1, using measure: "record_linkage"}

\item{n_sampling}{integer of record linkage number of random sampling, input FALSE when not using this function; default=FALSE, using measure: "record_linkage"}

\item{cl_target}{character; target variable used for cl_overlap; using measure: "cl_overlap"}

\item{cl_measure}{character or logical; \{ 'True', 'FALSE', TRUE, FALSE \}; using measure: "cl_overlap"}

\item{cl_m}{integer; using measure: "cl_overlap"}
}
\value{
A numeric or numeric list
}
\description{
This function calculates utility and risk measures for synthetic data.
x, x_link, and measure are required parameters,
and required parameters exist depending on the measure (see example)
}
\examples{
Utility
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'w_distance')
print(paste('w_distance:', result))
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'kl_divergence')
print(paste('kl_divergence:', result))
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'js_divergence')
print(paste('js_divergence:', result))
result <- Compute_Measure(orig_fact_df, syn_fact_df, measure = 'pmse')
print(paste('pmse:', result))
result <- Compute_Measure(orig_fact_df, syn_fact_df, measure = 'standard_pmse')
print(paste('standard_pmse:', result))
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'alpha_precision')
print(paste('alpha_precision:', result))
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'beta_recall')
print(paste('beta_recall:', result))
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'cl_overlap', cl_target='BIS_MNTH')
print(paste('cl_overlap:', result)) # >> glm의 coefficient가 NA를 뱉는 경우 NA를 반환하게 작성되어 있음.
# Risk
result <- Compute_Measure(orig_fact_df, syn_fact_df, measure = 'idr', sensitive_var = 'BIS_MNTH')
print(paste('idr:', result))
result_list <- Compute_Measure(orig_fact_df, syn_fact_df, measure = 'cap', sensitive_var = 'BIS_MNTH')
print(paste('cap:', result_list)) # >> CAP_0, CAP_NA로 이루어진 리스트 반환
result <- Compute_Measure(orig_fact_df, syn_fact_df, measure = 'pop_uni')
print(paste('pop_uni:', result))
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'record_linkage', sensitive_var = 'BIS_MNTH')
print(paste('record_linkage:', result))
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'mia')
print(paste('mia:', result))
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'dcr')$DCR_mean
print(paste('dcr:', result))
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'nndr')$NNDR_mean
print(paste('nndr:', result)) # >> DCR, NNDR이 list형태로 반환되며 각각 nrow의 길이를 갖고 있어 각각의 평균 및 전체값을 리스트 형태로 반환 
result <- Compute_Measure(orig_num_df, syn_num_df, measure = 'authen')
print(paste('authen:', result))
}
